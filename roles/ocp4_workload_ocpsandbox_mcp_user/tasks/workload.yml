---
- name: Set user variable shorthand
  ansible.builtin.set_fact:
    _ocpsandbox_mcp_user: "{{ ocp4_workload_ocpsandbox_mcp_user_username }}"

# ------------------------------------------------------------------
# Discover cluster ingress domain (may not be set if keycloak_user
# role is not in the workloads list)
# ------------------------------------------------------------------
- name: Discover cluster ingress domain
  when: openshift_cluster_ingress_domain is not defined
  block:
  - name: Get cluster ingress config
    kubernetes.core.k8s_info:
      host: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url }}"
      api_key: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token }}"
      validate_certs: false
      api_version: config.openshift.io/v1
      kind: Ingress
      name: cluster
    register: r_ingress_config

  - name: Set ingress domain fact
    ansible.builtin.set_fact:
      openshift_cluster_ingress_domain: >-
        {{ r_ingress_config.resources[0].spec.domain }}

# ------------------------------------------------------------------
# Write kubeconfig as fallback for downstream roles (e.g., showroom,
# console_embed) that use kubernetes.core without explicit host:/api_key:.
# Primary auth is via K8S_AUTH_* env vars set by the AgnosticD namespace
# config framework. This is a safety net for e2e tests or environments
# where those env vars are not set.
# ------------------------------------------------------------------
- name: Determine kubeconfig path
  ansible.builtin.set_fact:
    _kubeconfig_path: >-
      {{ lookup('env', 'KUBECONFIG')
         | default(lookup('env', 'HOME') ~ '/.kube/config', true) }}

- name: Ensure kubeconfig directory exists
  ansible.builtin.file:
    path: "{{ _kubeconfig_path | dirname }}"
    state: directory
    mode: "0700"

- name: Write kubeconfig for downstream roles
  ansible.builtin.copy:
    dest: "{{ _kubeconfig_path }}"
    mode: "0600"
    content: |
      apiVersion: v1
      kind: Config
      clusters:
      - cluster:
          insecure-skip-tls-verify: true
          server: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url | trim }}"
        name: sandbox
      contexts:
      - context:
          cluster: sandbox
          user: admin
        name: sandbox
      current-context: sandbox
      users:
      - name: admin
        user:
          token: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token | trim }}"

# ==================================================================
# Create Gitea API token for MCP Server
# Gitea instance and user are provisioned by upstream roles
# (gitea_instance + gitea_user). The gitea_url fact is exported
# by gitea_instance.
# ==================================================================
- name: Delete existing Gitea token
  ansible.builtin.uri:
    url: >-
      {{ gitea_url }}/api/v1/users/{{ _ocpsandbox_mcp_user }}/tokens/{{ ocp4_workload_ocpsandbox_mcp_user_gitea_repository }}
    method: DELETE
    status_code: [204, 404, 422]
    user: "{{ _ocpsandbox_mcp_user }}"
    password: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_user_password }}"
    force_basic_auth: true
    validate_certs: true

- name: Create Gitea API token for MCP Server
  ansible.builtin.uri:
    url: >-
      {{ gitea_url }}/api/v1/users/{{ _ocpsandbox_mcp_user }}/tokens
    method: POST
    body:
      name: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_repository }}"
      scopes:
      - read:user
      - read:repository
      - read:issue
      - write:issue
    body_format: json
    status_code: 201
    user: "{{ _ocpsandbox_mcp_user }}"
    password: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_user_password }}"
    force_basic_auth: true
    validate_certs: true
  register: r_gitea_token

- name: Set Gitea token and LibreChat secret facts
  ansible.builtin.set_fact:
    _ocpsandbox_mcp_gitea_token: "{{ r_gitea_token.json.sha1 }}"
    _ocpsandbox_mcp_librechat_key32: "{{ lookup('password', '/dev/null chars=hexdigits length=32') | lower }}"
    _ocpsandbox_mcp_librechat_key16: "{{ lookup('password', '/dev/null chars=hexdigits length=16') | lower }}"

# ==================================================================
# Discover sandbox-created namespaces via guid label.
# The 'var' key in common.yaml sandboxes is not yet implemented in
# the sandbox API or AgnosticD, so namespace names are discovered
# from the cluster rather than relying on variable injection.
# ==================================================================
- name: Find all sandbox-created namespaces for this order
  kubernetes.core.k8s_info:
    host: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url }}"
    api_key: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token }}"
    validate_certs: false
    api_version: v1
    kind: Namespace
    label_selectors:
    - "created-by=sandbox-api"
    - "guid={{ sandbox_openshift_namespace | regex_replace('^sandbox-([^-]+)-.*', '\\1') }}"
  register: r_sandbox_namespaces

- name: Set namespace facts from discovered sandbox namespaces
  ansible.builtin.set_fact:
    ocp4_workload_ocpsandbox_mcp_user_librechat_namespace: >-
      {{ r_sandbox_namespaces.resources | map(attribute='metadata.name')
         | select('match', '.*-librechat$') | list | first }}
    ocp4_workload_ocpsandbox_mcp_user_mcp_gitea_namespace: >-
      {{ r_sandbox_namespaces.resources | map(attribute='metadata.name')
         | select('match', '.*-mcp-gitea$') | list | first }}
    ocp4_workload_ocpsandbox_mcp_user_openshift_namespace: >-
      {{ r_sandbox_namespaces.resources | map(attribute='metadata.name')
         | select('match', '.*-mcp-openshift$') | list | first }}
    ocp4_workload_ocpsandbox_mcp_user_gitea_namespace: >-
      {{ r_sandbox_namespaces.resources | map(attribute='metadata.name')
         | select('match', '.*-[0-9]+-gitea$') | list | first }}

# ==================================================================
# Patch LimitRange in all sandbox namespaces with container defaults.
# The sandbox API creates a LimitRange (sandbox-limit-range) but with
# limits: null. This patch adds proper defaults so that any container
# without explicit resources (e.g. Tekton init containers) gets them
# automatically, satisfying the namespace quota enforcement.
# ==================================================================
- name: Patch LimitRange with container defaults in all sandbox namespaces
  kubernetes.core.k8s:
    host: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url }}"
    api_key: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token }}"
    validate_certs: false
    state: present
    definition:
      apiVersion: v1
      kind: LimitRange
      metadata:
        name: sandbox-limit-range
        namespace: "{{ item }}"
      spec:
        limits:
        - type: Container
          default:
            cpu: 500m
            memory: 512Mi
          defaultRequest:
            cpu: 50m
            memory: 128Mi
  loop: "{{ r_sandbox_namespaces.resources | map(attribute='metadata.name') | list }}"

# ==================================================================
# Create ArgoCD ApplicationSets
# All namespaces are created by the sandbox API (cluster_condition: same(cluster))
# ==================================================================
- name: Create MCP lab components
  kubernetes.core.k8s:
    host: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url }}"
    api_key: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token }}"
    validate_certs: false
    state: present
    definition: "{{ lookup('template', item) | from_yaml }}"
  loop:
  - scc.yaml.j2
  - applicationset-mcp-openshift.yaml.j2
  - applicationset-mcp-gitea.yaml.j2
  - applicationset-librechat-config.yaml.j2
  - applicationset-librechat.yaml.j2
  - applicationset-agent.yaml.j2

# ==================================================================
# HTTP readiness checks -- verify key services are reachable before
# saving user info. Faster and more direct than waiting for ArgoCD
# Healthy status, which can lag behind actual service availability.
# ==================================================================
- name: Verify LibreChat is reachable
  ansible.builtin.uri:
    url: >-
      https://librechat-{{ ocp4_workload_ocpsandbox_mcp_user_librechat_namespace }}.{{ openshift_cluster_ingress_domain }}
    method: GET
    status_code: [200, 302, 301]
    validate_certs: true
  register: r_librechat
  retries: 20
  delay: 30
  until: r_librechat.status in [200, 302, 301]

- name: Verify OpenShift MCP server is reachable
  ansible.builtin.uri:
    url: >-
      https://mcp-openshift-{{ ocp4_workload_ocpsandbox_mcp_user_openshift_namespace }}.{{ openshift_cluster_ingress_domain }}/health
    method: GET
    status_code: [200, 404]
    validate_certs: true
  register: r_mcp_openshift
  retries: 20
  delay: 30
  until: r_mcp_openshift.status in [200, 404]

- name: Verify Gitea MCP server is reachable
  ansible.builtin.uri:
    url: >-
      https://mcp-gitea-{{ ocp4_workload_ocpsandbox_mcp_user_mcp_gitea_namespace }}.{{ openshift_cluster_ingress_domain }}/health
    method: GET
    status_code: [200, 404]
    validate_certs: true
  register: r_mcp_gitea
  retries: 20
  delay: 30
  until: r_mcp_gitea.status in [200, 404]

# ==================================================================
# Save user information
# ==================================================================
- name: Save user information
  agnosticd.core.agnosticd_user_info:
    user: "{{ _ocpsandbox_mcp_user }}"
    data:
      user: "{{ _ocpsandbox_mcp_user }}"
      password: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_user_password }}"
      librechat_url: >-
        https://librechat-{{ ocp4_workload_ocpsandbox_mcp_user_librechat_namespace }}.{{ openshift_cluster_ingress_domain }}
      librechat_user: "{{ _ocpsandbox_mcp_user }}@{{ ocp4_workload_ocpsandbox_mcp_user_librechat_email_domain }}"
      librechat_password: "{{ ocp4_workload_ocpsandbox_mcp_user_librechat_password }}"
      openshift_mcp_server_url: >-
        https://mcp-openshift-{{ ocp4_workload_ocpsandbox_mcp_user_openshift_namespace }}.{{ openshift_cluster_ingress_domain }}/sse#openshift
      gitea_mcp_server_url: >-
        https://mcp-gitea-{{ ocp4_workload_ocpsandbox_mcp_user_mcp_gitea_namespace }}.{{ openshift_cluster_ingress_domain }}/mcp
