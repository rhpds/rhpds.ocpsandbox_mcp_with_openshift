---
- name: Set user variable shorthand
  ansible.builtin.set_fact:
    _ocpsandbox_mcp_user: "{{ ocp4_workload_ocpsandbox_mcp_user_username }}"

# ------------------------------------------------------------------
# Discover cluster ingress domain (may not be set if keycloak_user
# role is not in the workloads list)
# ------------------------------------------------------------------
- name: Discover cluster ingress domain
  when: openshift_cluster_ingress_domain is not defined
  block:
  - name: Get cluster ingress config
    kubernetes.core.k8s_info:
      host: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url }}"
      api_key: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token }}"
      validate_certs: false
      api_version: config.openshift.io/v1
      kind: Ingress
      name: cluster
    register: r_ingress_config

  - name: Set ingress domain fact
    ansible.builtin.set_fact:
      openshift_cluster_ingress_domain: >-
        {{ r_ingress_config.resources[0].spec.domain }}

# ------------------------------------------------------------------
# Write kubeconfig as fallback for downstream roles (e.g., showroom,
# console_embed) that use kubernetes.core without explicit host:/api_key:.
# Primary auth is via K8S_AUTH_* env vars set by the AgnosticD namespace
# config framework. This is a safety net for e2e tests or environments
# where those env vars are not set.
# ------------------------------------------------------------------
- name: Determine kubeconfig path
  ansible.builtin.set_fact:
    _kubeconfig_path: >-
      {{ lookup('env', 'KUBECONFIG')
         | default(lookup('env', 'HOME') ~ '/.kube/config', true) }}

- name: Ensure kubeconfig directory exists
  ansible.builtin.file:
    path: "{{ _kubeconfig_path | dirname }}"
    state: directory
    mode: "0700"

- name: Write kubeconfig for downstream roles
  ansible.builtin.copy:
    dest: "{{ _kubeconfig_path }}"
    mode: "0600"
    content: |
      apiVersion: v1
      kind: Config
      clusters:
      - cluster:
          insecure-skip-tls-verify: true
          server: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url | trim }}"
        name: sandbox
      contexts:
      - context:
          cluster: sandbox
          user: admin
        name: sandbox
      current-context: sandbox
      users:
      - name: admin
        user:
          token: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token | trim }}"

# ==================================================================
# Create Gitea API token for MCP Server
# Gitea instance and user are provisioned by upstream roles
# (gitea_instance + gitea_user). The gitea_url fact is exported
# by gitea_instance.
# ==================================================================
- name: Delete existing Gitea token
  ansible.builtin.uri:
    url: >-
      {{ gitea_url }}/api/v1/users/{{ _ocpsandbox_mcp_user }}/tokens/{{ ocp4_workload_ocpsandbox_mcp_user_gitea_repository }}
    method: DELETE
    status_code: [204, 404, 422]
    user: "{{ _ocpsandbox_mcp_user }}"
    password: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_user_password }}"
    force_basic_auth: true
    validate_certs: true

- name: Create Gitea API token for MCP Server
  ansible.builtin.uri:
    url: >-
      {{ gitea_url }}/api/v1/users/{{ _ocpsandbox_mcp_user }}/tokens
    method: POST
    body:
      name: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_repository }}"
      scopes:
      - read:user
      - read:repository
      - read:issue
      - write:issue
    body_format: json
    status_code: 201
    user: "{{ _ocpsandbox_mcp_user }}"
    password: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_user_password }}"
    force_basic_auth: true
    validate_certs: true
  register: r_gitea_token

- name: Set Gitea token and LibreChat secret facts
  ansible.builtin.set_fact:
    _ocpsandbox_mcp_gitea_token: "{{ r_gitea_token.json.sha1 }}"
    _ocpsandbox_mcp_librechat_key32: "{{ lookup('password', '/dev/null chars=hexdigits length=32') | lower }}"
    _ocpsandbox_mcp_librechat_key16: "{{ lookup('password', '/dev/null chars=hexdigits length=16') | lower }}"

# ==================================================================
# Create ArgoCD ApplicationSets
# ==================================================================
- name: Create MCP lab components
  kubernetes.core.k8s:
    host: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_url }}"
    api_key: "{{ ocp4_workload_ocpsandbox_mcp_user_openshift_api_token }}"
    validate_certs: false
    state: present
    definition: "{{ lookup('template', item) | from_yaml }}"
  loop:
  - scc.yaml.j2
  - applicationset-mcp-openshift.yaml.j2
  - applicationset-mcp-gitea.yaml.j2
  - applicationset-librechat-config.yaml.j2
  - applicationset-librechat.yaml.j2
  - applicationset-agent.yaml.j2

- name: Save user information
  agnosticd.core.agnosticd_user_info:
    user: "{{ _ocpsandbox_mcp_user }}"
    data:
      user: "{{ _ocpsandbox_mcp_user }}"
      password: "{{ ocp4_workload_ocpsandbox_mcp_user_gitea_user_password }}"
      librechat_url: >-
        https://librechat-{{ ocp4_workload_ocpsandbox_mcp_user_librechat_namespace }}.{{ openshift_cluster_ingress_domain }}
      librechat_user: "{{ _ocpsandbox_mcp_user }}@{{ ocp4_workload_ocpsandbox_mcp_user_librechat_email_domain }}"
      librechat_password: "{{ ocp4_workload_ocpsandbox_mcp_user_librechat_password }}"
      openshift_mcp_server_url: >-
        https://mcp-openshift-{{ ocp4_workload_ocpsandbox_mcp_user_openshift_namespace }}.{{ openshift_cluster_ingress_domain }}/sse#openshift
      gitea_mcp_server_url: >-
        https://mcp-gitea-{{ ocp4_workload_ocpsandbox_mcp_user_mcp_gitea_namespace }}.{{ openshift_cluster_ingress_domain }}/mcp
